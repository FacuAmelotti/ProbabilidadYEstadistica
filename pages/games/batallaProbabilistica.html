<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Batalla de Probabilidad</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;700&family=Manrope:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    /* ===========================
       RESET & BASE
       =========================== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Manrope', sans-serif;
      background: #0a0a0a;
      color: #ffffff;
    }

    /* ===========================
       ANIMATED BACKGROUND
       =========================== */
    .animated-bg {
      position: fixed;
      inset: 0;
      z-index: -1;
      background: radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
                  radial-gradient(circle at 40% 80%, rgba(120, 119, 198, 0.08) 0%, transparent 50%);
      animation: breathe 8s ease-in-out infinite;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .floating-elements {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
    }

    .floating-dot {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255);
      border-radius: 50%;
      animation: float 20s linear infinite;
    }

    .floating-dot:nth-child(1) { top: 10%; left: 10%; animation-delay: 0s; }
    .floating-dot:nth-child(2) { top: 20%; left: 80%; animation-delay: 2s; }
    .floating-dot:nth-child(3) { top: 60%; left: 20%; animation-delay: 4s; }
    .floating-dot:nth-child(4) { top: 80%; left: 70%; animation-delay: 6s; }
    .floating-dot:nth-child(5) { top: 40%; left: 90%; animation-delay: 8s; }

    @keyframes float {
      0% { transform: translate(0, 0) scale(1); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translate(-100vw, -20px) scale(0.5); opacity: 0; }
    }

    /* ===========================
       NAVIGATION
       =========================== */
    .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      padding: 12px 24px;
      background: rgba(10, 10, 10, 0.85);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      height: 56px;
    }

    .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 100%;
    }

    .logo {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #ffffff, #a0a0a0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo img {
      height: 32px;
      width: auto;
      filter: drop-shadow(0 0 4px rgba(255,255,255,0.2));
      border-radius: 50%;
    }

    .nav-menu {
      display: flex;
      gap: 20px;
      list-style: none;
      align-items: center;
    }

    .nav-link {
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: color 0.3s ease;
    }

    .nav-link:hover {
      color: #ffffff;
    }

    /* ===========================
       LAYOUT PRINCIPAL
       =========================== */
    .game-container {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 72px;
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 16px;
      padding: 16px;
      overflow: hidden;
    }

    /* ===========================
       BATTLEFIELD
       =========================== */
    .battlefield {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .battlefield-header {
      margin-bottom: 12px;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 300;
      background: linear-gradient(135deg, #ffffff, #a0a0a0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .grid-3 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      flex: 1;
      min-height: 0;
    }

    .cell {
      border: 1px dashed rgba(255,255,255,0.15);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background: rgba(255,255,255,0.02);
      min-height: 0;
    }

    .castle {
      width: 85%;
      max-width: 200px;
      border-radius: 12px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.04));
      border: 1px solid rgba(255,255,255,0.15);
      text-align: center;
      box-shadow: inset 0 0 12px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      gap: 6px;
      justify-content: center;
    }

    .castle .name {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .lifes {
      font-size: 16px;
      letter-spacing: 2px;
      filter: drop-shadow(0 0 4px rgba(0,255,128,0.2));
    }

    .tag {
      position: absolute;
      top: 6px;
      left: 6px;
      font-size: 11px;
      opacity: 0.5;
    }

    .active-turn {
      outline: 2px solid #00ff99;
      box-shadow: 0 0 20px rgba(0,255,153,0.2);
    }

    /* ===========================
       SIDEBAR HUD
       =========================== */
    .side-hud {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.2) transparent;
    }

    .side-hud::-webkit-scrollbar {
      width: 4px;
    }

    .side-hud::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    .hud-block {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
    }

    .hud-block h3 {
      font-size: 0.9rem;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    .small {
      font-size: 0.85rem;
      opacity: 0.75;
    }

    .muted {
      opacity: 0.6;
    }

    .timerbar {
      height: 8px;
      width: 100%;
      background: rgba(255,255,255,0.07);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 6px;
    }

    .timerbar > div {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #00d084, #9cffac);
      transition: width 0.2s linear;
    }

    .log {
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.85rem;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.2) transparent;
    }

    .log::-webkit-scrollbar {
      width: 4px;
    }

    .log::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    .log p {
      margin-bottom: 6px;
      line-height: 1.4;
    }

    /* ===========================
       PLAYER HUD (INFERIOR)
       =========================== */
    .player-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 72px;
      background: rgba(10,10,10,0.9);
      backdrop-filter: blur(16px);
      border-top: 1px solid rgba(255,255,255,0.1);
      padding: 12px 24px;
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 16px;
      z-index: 900;
    }

    .action-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .btn-ghost {
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 999px;
      padding: 8px 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .btn-ghost:hover {
      background: rgba(255,255,255,0.08);
    }

    .btn-danger {
      border-color: rgba(255, 99, 132, 0.6);
    }

    .btn-good {
      border-color: rgba(0, 255, 153, 0.6);
    }

    .disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .targets {
      display: none;
      gap: 6px;
    }

    .targets.active {
      display: flex;
    }

    .hearts-lg {
      font-size: 18px;
      letter-spacing: 3px;
    }

    /* ===========================
       MODAL
       =========================== */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
      padding: 20px;
    }

    .modal.active {
      display: flex;
    }

    .modal-card {
      width: min(680px, 100%);
      max-height: 90vh;
      overflow-y: auto;
      background: rgb(16, 16, 16);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .q-topic {
      font-size: 0.85rem;
      opacity: 0.85;
      margin-bottom: 8px;
      color: #9AFF9A;
    }

    .q-title {
      font-size: 1.45rem;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .options {
      display: grid;
      gap: 8px;
    }

    .opt {
      text-align: left;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.04);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.95rem;
      color: #9177c9;
    }

    .opt:hover {
      transform: translateY(-1px);
      background: rgba(255,255,255,0.08);
    }

    .explain {
      margin-top: 12px;
      display: none;
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .chip {
      padding: 5px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }

    .right {
      color: #00ff99;
    }

    .wrong {
      color: #ff6b6b;
    }

    /* ===========================
       OVERLAYS
       =========================== */
    .overlay-center {
      position: fixed;
      inset: 0;
      z-index: 1300;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0);
      padding: 20px;
    }

    .overlay-center.active {
      display: flex;
    }

    .start-card,
    .end-card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      padding: 24px;
      width: min(680px, 100%);
      max-height: 90vh;
      overflow-y: auto;
      text-align: center;
    }

    .infotext-box {
      background: rgba(255,255,255,0.04);
      padding: 16px;
      border-radius: 10px;
      margin: 16px 0;
      text-align: left;
    }

    .infotext-box h4 {
      margin-bottom: 8px;
      color: #00ff99;
    }

    .infotext-box ul {
      padding-left: 20px;
    }

    .infotext-box li {
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .btn {
      padding: 12px 28px;
      border: none;
      border-radius: 50px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ffffff, #e0e0e0);
      color: #000000;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 255, 255, 0.2);
    }

    .mt-1 { margin-top: 8px; }
    .mt-2 { margin-top: 16px; }
    .mb-2 { margin-bottom: 16px; }

.castle-info {
  display: flex;
  align-items: center;
  gap: 8px;
  justify-content: center;
}

.avatar {
  width: 48px;
  height: 48px;
  background-size: cover;
  background-position: center;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.15);
  box-shadow: 0 0 8px rgba(0,0,0,0.3);
}

.avatar.dead {
  filter: grayscale(100%) brightness(0.5);
  opacity: 0.6;
}

/* Efecto de turno activo en HUD inferior */
.player-hud.active-turn {
  background: linear-gradient(180deg, rgba(0,255,153,0.15), rgba(0,255,153,0.05));
  border-top: 1px solid rgba(49, 174, 86, 0.4);
  box-shadow: 0 0 25px rgba(61, 167, 66, 0.25);
  transition: all 0.4s ease;
}


/* ===========================
   MUSIC PANEL (INLINE NAV)
   =========================== */
.music-panel-inline {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: 12px;
  padding-left: 12px;
  border-left: 1px solid rgba(255,255,255,0.15);
}

#btnPlayMusic {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 6px;
  color: white;
  cursor: pointer;
  padding: 4px 6px;
  transition: 0.2s;
  font-size: 14px;
}

#btnPlayMusic:hover {
  background: rgba(255,255,255,0.1);
}

#volumeControl {
  width: 80px;
  height: 4px;
  accent-color: #00ff99;
  cursor: pointer;
}

/* ===========================
   BATTLE GRID - TABLA NORMAL
   =========================== */
.battle-grid {
  display: grid;
  width: 100%;
  height: 100%;
  gap: 12px;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  justify-items: center;
  align-items: center;
  padding: 20px;
  border-radius: 16px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.05);
}

/* Casilla base */
.cell {
  width: 100%;
  height: 100%;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.02);
  border: 1px dashed rgba(255,255,255,0.08);
  transition: all 0.3s ease;
}

.cell:hover {
  background: rgba(255,255,255,0.05);
  transform: scale(1.02);
}

/* Contenido del jugador o bot */
.castle {
  width: 85%;
  height: 85%;
  border-radius: 12px;
  padding: 12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.02));
  border: 1px solid rgba(255,255,255,0.15);
  text-align: center;
  box-shadow: inset 0 0 12px rgba(0,0,0,0.4);
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 6px;
}

.castle .name {
  font-weight: 600;
  font-size: 0.9rem;
}

.castle .lifes {
  font-size: 1rem;
  letter-spacing: 2px;
}

.castle {
  opacity: 0;
  transform: scale(0.9);
  animation: fadeInCastle 0.6s ease forwards;
}

@keyframes fadeInCastle {
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* ===========================
   TURNOS Y EFECTO ACTIVO
   =========================== */
.cell.active-turn .castle {
  border: 1px solid rgba(0,255,153,0.8);
  box-shadow: 0 0 20px rgba(0,255,153,0.4);
  transform: scale(1.05);
  transition: 0.25s;
}

@keyframes pulseTurn {
  0%, 100% { box-shadow: 0 0 12px rgba(0,255,153,0.3); }
  50% { box-shadow: 0 0 24px rgba(0,255,153,0.6); }
}

.cell.active-turn .castle {
  border: 1px solid rgba(0,255,153,0.8);
  animation: pulseTurn 1.8s ease-in-out infinite;
  transform: scale(1.05);
}

.cell.flash-green {
  animation: flashGreen 1.2s ease;
}
.cell.flash-red {
  animation: flashRed 1.2s ease;
}
.cell.flash-violet {
  animation: flashViolet 1.2s ease;
}

@keyframes flashGreen {
  0%   { box-shadow: 0 0 25px rgba(0,255,153,0.8); background: rgba(0,255,153,0.15); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}

@keyframes flashRed {
  0%   { box-shadow: 0 0 25px rgba(255,80,80,0.8); background: rgba(255,80,80,0.15); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}

@keyframes flashViolet {
  0%   { box-shadow: 0 0 25px rgba(150,80,255,0.8); background: rgba(150,80,255,0.15); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}


/* ===========================
   DISTRIBUCI√ìN NORMAL (4 rivales)
   =========================== */
.battle-grid.normal #p1 { grid-area: 1 / 2; }
.battle-grid.normal #p2 { grid-area: 2 / 1; }
.battle-grid.normal #p3 { grid-area: 2 / 3; }
.battle-grid.normal #p4 { grid-area: 3 / 2; }
.battle-grid.normal #player { grid-area: 3 / 2; }

.battle-grid.full #p1 { grid-area: 1 / 1; }
.battle-grid.full #p2 { grid-area: 1 / 2; }
.battle-grid.full #p3 { grid-area: 1 / 3; }
.battle-grid.full #p4 { grid-area: 2 / 1; }
.battle-grid.full #p5 { grid-area: 2 / 3; }
.battle-grid.full #p6 { grid-area: 3 / 1; }
.battle-grid.full #p7 { grid-area: 3 / 3; }
.battle-grid.full #player { grid-area: 3 / 2; }

/* ===========================
   DISTRIBUCI√ìN FULL (8 rivales)
   =========================== */
/* ===========================
   DISTRIBUCI√ìN FULL (8 rivales)
   =========================== */
.battle-grid.full #p1 { grid-area: 1 / 1; }
.battle-grid.full #p2 { grid-area: 1 / 2; }
.battle-grid.full #p3 { grid-area: 1 / 3; }
.battle-grid.full #p4 { grid-area: 2 / 1; }
.battle-grid.full #p5 { grid-area: 2 / 3; }
.battle-grid.full #p6 { grid-area: 3 / 1; }
.battle-grid.full #p7 { grid-area: 3 / 3; }
.battle-grid.full #p8 { grid-area: 2 / 2; display: none; } /* centro vac√≠o */
.battle-grid.full #player { grid-area: 3 / 2; } /* jugador abajo centro */

/* ===========================
   EFECTO DE PROYECTIL
   =========================== */
/* ===========================
   EFECTO DE PROYECTIL R√ÅPIDO (VIOLETA)
   =========================== */
.projectile {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: radial-gradient(circle, #d28bff 0%, #8a2be2 60%, #4b0082 100%);
  pointer-events: none;
  z-index: 3000;
  box-shadow: 0 0 25px rgba(190, 80, 255, 0.9);
  transform: translate(-50%, -50%) scale(1);
  opacity: 0.95;
  transition: transform 0.35s ease-in, opacity 0.25s ease-out;
}


#targetBox.attack-mode .btn-ghost {
  border-color: rgba(255, 80, 80, 0.7);
  color: #ff8080;
  background-color: rgb(58, 22, 22);
}

#targetBox.attack-mode .btn-ghost:hover {
  background: rgba(255, 80, 80, 0.15);
  color: #ffb3b3;
}

/* =====================================================
   EFECTOS VISUALES EXTRA
   ===================================================== */

/* üíö Curaci√≥n (heal) */
.effect-heal {
  position: absolute;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: radial-gradient(circle, #00ff99 0%, #008f5a 80%);
  box-shadow: 0 0 30px rgba(0,255,153,0.7);
  z-index: 3000;
  opacity: 0.9;
  animation: healEffect 0.8s ease-out forwards;
}

@keyframes healEffect {
  0% { transform: scale(0.8); opacity: 1; }
  60% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(2.2); opacity: 0; }
}

/* üíô Fortificar (shield) */
.effect-shield {
  position: absolute;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: radial-gradient(circle, #00ccff 0%, #0066ff 80%);
  box-shadow: 0 0 25px rgba(0,180,255,0.8);
  z-index: 3000;
  opacity: 0.95;
  animation: shieldEffect 1s ease-out forwards;
}

@keyframes shieldEffect {
  0% { transform: scale(0.7); opacity: 1; }
  50% { transform: scale(1.4); opacity: 0.9; }
  100% { transform: scale(2); opacity: 0; }
}

/* üíî Fallo (miss/fail) */
.effect-fail {
  position: absolute;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: radial-gradient(circle, #ff4444 0%, #990000 80%);
  box-shadow: 0 0 25px rgba(255,80,80,0.9);
  z-index: 3000;
  opacity: 0.9;
  animation: failEffect 0.7s ease-out forwards;
}

@keyframes failEffect {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(2.3); opacity: 0; }
}


@media (max-width: 768px) {
  .music-panel-inline {
    display: none; /* ocultar en pantallas peque√±as si quer√©s */
  }
}


@keyframes flashGreen {
  0%   { box-shadow: 0 0 20px rgba(0,255,153,0.8); background: rgba(0,255,153,0.1); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}

@keyframes flashRed {
  0%   { box-shadow: 0 0 20px rgba(255,80,80,0.8); background: rgba(255,80,80,0.1); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}

@keyframes flashViolet {
  0%   { box-shadow: 0 0 20px rgba(150,80,255,0.8); background: rgba(150,80,255,0.1); }
  100% { box-shadow: none; background: rgba(255,255,255,0.02); }
}

    /* ===========================
       RESPONSIVE
       =========================== */
    @media (max-width: 1024px) {
      .game-container {
        grid-template-columns: 1fr 240px;
      }
    }

    @media (max-width: 768px) {
      .navbar {
        padding: 10px 16px;
        height: 50px;
      }

      .logo {
        font-size: 18px;
      }

      .logo img {
        height: 28px;
      }

      .nav-menu {
        gap: 12px;
      }

      .nav-link {
        font-size: 13px;
      }

      .game-container {
        top: 50px;
        bottom: 66px;
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
        padding: 12px;
        gap: 12px;
      }

      .side-hud {
        max-height: 30vh;
      }

      .player-hud {
        height: 66px;
        padding: 10px 16px;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .action-group {
        gap: 6px;
      }

      .btn-ghost {
        padding: 7px 12px;
        font-size: 0.85rem;
      }

      .hearts-lg {
        font-size: 16px;
        letter-spacing: 2px;
      }

      .castle {
        padding: 8px;
      }

      .castle .name {
        font-size: 0.85rem;
      }

      .lifes {
        font-size: 14px;
      }
    }

    @media (max-width: 480px) {
      .grid-3 {
        gap: 8px;
      }

      .section-title {
        font-size: 1.2rem;
      }

      .hud-block h3 {
        font-size: 0.85rem;
      }

      .btn-ghost {
        font-size: 0.8rem;
        padding: 6px 10px;
      }
    }

    
  </style>
</head>
<body>
  <!-- Fondo animado -->
  <div class="animated-bg"></div>
  <div class="floating-elements">
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
    <div class="floating-dot"></div>
  </div>

  <!-- NAV -->
  <nav class="navbar">
    <div class="nav-container">
      <a href="#" class="logo">
        <span>PyE</span>
      </a>
      <ul class="nav-menu">
  <li><a class="nav-link" href="#" id="btnHelp">Ayuda</a></li>
  <li><a class="nav-link" href="#" id="btnRestart">Reiniciar</a></li>
  <li><a class="nav-link" href="../temario.html" id="btnExit">Salir</a></li>

  <!-- üéµ Panel de m√∫sica -->
  <div class="music-panel-inline">
    <button id="btnPlayMusic">‚èØÔ∏è</button>
    <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.15">
  </div>
</ul>

    </div>
  </nav>

  <!-- CONTENIDO PRINCIPAL -->
  <div class="game-container">
    <!-- Campo de batalla -->
<section class="battlefield">
  <div class="battlefield-header">
    <h2 class="section-title">Batalla de Probabilidad</h2>
  </div>

<div class="battle-grid" id="grid">
  <div class="cell" id="p1"></div>
  <div class="cell" id="p2"></div>
  <div class="cell" id="p3"></div>
  <div class="cell" id="p4"></div>
  <div class="cell" id="p5"></div>
  <div class="cell" id="p6"></div>
  <div class="cell" id="p7"></div>
  <div class="cell" id="p8"></div>
  <div class="cell" id="player"></div>
</div>


</section>

    <!-- HUD lateral -->
    <aside class="side-hud">
      <div class="hud-block">
        <h3>Estado</h3>
        <p class="small">Ronda: <b id="round">1</b></p>
        <p class="small">Turno: <b id="turnName">‚Äî</b></p>
        <div class="timerbar mt-1"><div id="timerFill"></div></div>
        <p class="small mt-1">Tiempo: <b id="timeLeft">20s</b></p>
      </div>
      <div class="hud-block">
        <h3>Puntaje</h3>
        <p>Actual: <b id="score">0</b></p>
        <p class="muted small">M√°ximo: <b id="best">0</b></p>
      </div>
      <div class="hud-block">
        <h3>Log</h3>
        <div class="log" id="log"></div>
      </div>
      <div class="hud-block">
        <h3>Consejo</h3>
        <p class="small" id="tip">Si A y B son independientes, P(A‚à©B)=P(A)¬∑P(B).</p>
      </div>
    </aside>
  </div>

  <!-- PlayerHUD -->
  <div class="player-hud">
    <div class="action-group">
      <button class="btn-ghost btn-danger" id="btnAttack">‚öîÔ∏è Atacar</button>
      <button class="btn-ghost btn-good" id="btnFortify">üõ°Ô∏è Fortificar</button>
      <button class="btn-ghost" id="btnRepair">‚ù§Ô∏è Curar</button>
      <button class="btn-ghost" id="btnSpy">üïµÔ∏è Espiar</button>
      <div class="targets" id="targetBox"></div>
    </div>
    <div>
      <span class="small">Tus vidas: </span>
      <span class="hearts-lg" id="playerHearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    </div>
  </div>

  <!-- Modal preguntas -->
  <div class="modal" id="qModal">
    <div class="modal-card">
      <div class="q-topic" id="qTopic">Tema</div>
      <div class="q-title" id="qTitle">Pregunta</div>
      <div class="options" id="qOptions"></div>
      <div class="explain" id="qExplain"></div>
      <div class="chips">
<div class="mt-2" style="text-align:right;">
  <button id="btnCloseQuestion" class="btn-ghost small">‚ùå Cerrar</button>
</div>

        <span class="chip" id="chipBonus" style="display:none;">üéØ +15% bonus</span>
      </div>
    </div>
  </div>

  <!-- Overlay Inicio -->
  <div class="overlay-center active" id="startOverlay">
    <div class="start-card">
      <h2 class="section-title" style="margin-bottom:12px;">Batalla de Probabilidad</h2>
      <p class="mb-2">¬°Sobrevive y gana a los 3 rivales resolviendo preguntas!</p>
      <div class="infotext-box">
        <h4>¬øC√≥mo se juega?</h4>
        <ul>
          <li>Turnos de <b>20s</b>. Si no actu√°s, perd√©s el turno y <b>-1 vida</b>.</li>
          <li><b>Atacar</b>: acierto <b>-2 vidas</b> al objetivo; fallo <b>-1 vida</b> propia.</li>
          <li><b>Fortificar</b>: acierto <b>+3 vida</b>.</li>
          <li><b>Reparar</b>: <b>+1 vida</b> sin pregunta.</li>
          <li><b>Espiar</b>: tema probable pr√≥ximo + <b>+15% √©xito</b> siguiente acci√≥n.</li>
        </ul>
      </div>
      <div class="mt-2">
        <label class="small">Tu nombre: </label>
        <input id="playerNameInput" class="btn-ghost" style="padding:8px 12px;" placeholder="Jugador" />
      </div>
      <div class="mt-2">
  <label class="small">Modo de juego:</label>
  <div class="btn-ghost" style="display:inline-flex; gap:12px; align-items:center; padding:8px 12px;">
    <label style="display:flex; gap:6px; align-items:center; cursor:pointer;">
      <input type="radio" name="gameMode" id="modeNormal" value="normal" >
      Normal (4 jugadores)
    </label>
    <label style="display:flex; gap:6px; align-items:center; cursor:pointer;">
      <input type="radio" name="gameMode" id="modeFull" value="full" checked>
      Casa llena (8 jugadores)
    </label>
  </div>
</div>

      <button class="btn btn-primary mt-2" id="btnStart">Comenzar</button>
    </div>
  </div>

  <!-- Overlay Game Over -->
  <div class="overlay-center" id="endOverlay">
    <div class="end-card">
      <h2 class="section-title" id="endTitle">Fin de la partida</h2>
      <p id="endStats" class="mb-2"></p>
      <button class="btn btn-primary" id="btnPlayAgain">Jugar de nuevo</button>
    </div>
  </div>


    <script>
        // ============================================
    // BATALLA DE PROBABILIDAD - Script Completo Corregido
    // ============================================

    // Utilidades b√°sicas
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const logBox = $("#log");

    function addLog(text) {
    const p = document.createElement("p");
    p.innerHTML = text;
    logBox.prepend(p);
    // Auto-scroll y limitar historial
    while (logBox.children.length > 20) {
        logBox.removeChild(logBox.lastChild);
    }
    }

    function clamp(n, a, b) { 
    return Math.max(a, Math.min(b, n)); 
    }

    function hearts(n) { 
    return "‚ù§Ô∏è".repeat(Math.max(0, n)) + "ü§ç".repeat(Math.max(0, 6-n)); 
    }

    function rnd(arr) { 
    return arr[Math.floor(Math.random() * arr.length)]; 
    }

    // ============================================
    // BANCO DE PREGUNTAS
    // ============================================
 let QUESTIONS = [];

async function loadQuestions() {
  try {
    const res = await fetch("../../src/json/battleGame.json"); // üîπ ajust√° la ruta seg√∫n tu estructura
    if (!res.ok) throw new Error("Error al cargar preguntas");
    QUESTIONS = await res.json();
    console.log("‚úÖ Preguntas cargadas:", QUESTIONS.length);
  } catch (err) {
    console.error("‚ùå No se pudieron cargar las preguntas:", err);
    alert("Error al cargar las preguntas. Ver consola.");
  }
}

    // ============================================
    // CONSTANTES Y ESTADO GLOBAL
    // ============================================
    const MAX_HP = 6;
    const INIT_HP = 5;
    const TURN_TIME = 20;

    let state = null;
    let gameEnded = false;

    const baseTips = [
    "Si A y B son independientes, P(A‚à©B)=P(A)¬∑P(B).",
    "P(A·∂ú)=1‚àíP(A). √ötil cuando calcular el complemento es m√°s f√°cil.",
    "P(A‚à™B)=P(A)+P(B)‚àíP(A‚à©B).",
    "Teorema de Bayes: actualiza tu creencia con la evidencia.",
    "Probabilidad total: descompone A sobre una partici√≥n del espacio.",
    "Eventos excluyentes no pueden ocurrir simult√°neamente.",
    "P(A|B) mide la probabilidad de A dado que B ya ocurri√≥."
    ];

    // ============================================
    // INICIALIZACI√ìN DEL JUEGO
    // ============================================
function randomizeGridPositions(mode) {
  const grid = document.getElementById("grid");
  grid.classList.remove("normal", "full");
  grid.classList.add(mode);

  // üßπ Limpiar n√∫cleo anterior si existe
  const oldCore = grid.querySelector(".center-core");
  if (oldCore) oldCore.remove();

  // üéØ Posiciones disponibles para modo normal (forma de cruz)
  const normalPositions = [
    { id: "p1", area: "1 / 2" }, // arriba
    { id: "p2", area: "2 / 1" }, // izquierda
    { id: "p3", area: "2 / 3" }, // derecha
    { id: "p4", area: "3 / 1" }, // abajo-izquierda (extra si hay 4 bots)
  ];

  // üîÄ Barajamos las posiciones solo para los NPCs
  const shuffledNormal = normalPositions.sort(() => Math.random() - 0.5);

  // üéØ Posiciones para modo full (ya conocidas)
  const fullPositions = [
    { id: "p1", area: "1 / 1" },
    { id: "p2", area: "1 / 2" },
    { id: "p3", area: "1 / 3" },
    { id: "p4", area: "2 / 1" },
    { id: "p5", area: "2 / 3" },
    { id: "p6", area: "3 / 1" },
    { id: "p7", area: "3 / 3" },
  ];

  const positions = mode === "full" ? fullPositions : shuffledNormal;

  // üßç‚Äç‚ôÇÔ∏è Aplicar a las celdas
  positions.forEach((slot, i) => {
    const el = document.getElementById(slot.id);
    if (el) el.style.gridArea = slot.area;
  });

  // üë§ Jugador fijo en la parte inferior central
  const player = document.getElementById("player");
  if (player) player.style.gridArea = "3 / 2";

  // ‚ö° Si es modo FULL, agregamos el n√∫cleo visual (vac√≠o)
  if (mode === "full") {
    const center = document.createElement("div");
    center.className = "cell center-core";
    center.style.gridArea = "2 / 2";
    center.innerHTML = "<div class='core-energy'></div>";
    grid.appendChild(center);
  }
}

function newGame(playerName = "Jugador", mode = "normal") {
  const best = Number(localStorage.getItem("bp_best") || 0);
  $("#best").textContent = best;
  gameEnded = false;

  const players = buildPlayers(playerName, mode);

  state = {
    round: 1,
    turnIdx: 0,
    score: 0,
    timer: TURN_TIME,
    interval: null,
    awaitingAnswer: false,
    chosenAction: null,
    chosenTarget: null,
    spyBonus: false,
    players,
    order: players.map((_, idx) => idx), // 0..N-1
  };

  randomizeGridPositions(mode);


  logBox.innerHTML = "";
  $("#score").textContent = state.score;
  $("#round").textContent = state.round;
  $("#tip").textContent = rnd(baseTips);

  renderAll();
  highlightTurn();
  startTurnTimer();

  addLog("üéÆ <b>¬°Nueva partida iniciada!</b>");
  if (music.paused) {
    music.play();
    $("#btnPlayMusic").textContent = "‚è∏Ô∏è";
  }
}

    // ============================================
    // RENDERIZADO
    // ============================================
    function renderAll() {

// Render din√°mico seg√∫n existan jugadores
for (let i = 0; i < state.players.length; i++) {
  renderCastle(idFromIndex(i), state.players[i]);
}




    ["#dummy1", "#dummy2", "#dummy3", "#dummy4"].forEach(sel => {
        const box = $(sel);
        if (box) box.innerHTML = "";
    });

    // Vidas del jugador en HUD inferior
    $("#playerHearts").textContent = hearts(state.players[0].hp);

    // Habilitar/deshabilitar controles seg√∫n turno
    const myTurn = state.order[state.turnIdx] === 0 && !state.awaitingAnswer;
    togglePlayerControls(myTurn);
    }

function renderCastle(sel, p) {
  const box = $(sel);
  if (!box) return;

  if (!p || !p.alive) {
    box.innerHTML = `
      <div class="castle-info">
        <div class="avatar dead"></div>
        <div class="name muted">${p ? p.name || "‚Äî" : "‚Äî"}</div>
      </div>
      <div class="lifes">‚úñÔ∏é</div>
    `;
    box.parentElement.classList.remove("active-turn");
    return;
  }

  box.innerHTML = `
    <div class="castle-info">
      <div class="avatar" style="background-image:url('${p.img || 'img/default.png'}');"></div>
      <div>
        <div class="name">${p.name}</div>
        <div class="small muted">${p.type === 'bot' ? 'Bot' : 'Jugador'}</div>
      </div>
    </div>
    <div class="lifes">${hearts(p.hp)}</div>
  `;
}


function buildPlayers(playerName, mode) {
  // base de bots
  const baseBots = [
    { id: "L", name: "Laplace",   type: "bot", hp: INIT_HP, acc: 0.70, style: "cl√°sico",   alive: true, img: "../../src/img/visuales/pj_2.jpg" },
    { id: "F", name: "Frecuent√≠n",type: "bot", hp: INIT_HP, acc: 0.55, style: "emp√≠rico",  alive: true, img: "../../src/img/visuales/pj_3.jpg" },
    { id: "B", name: "Bayesito",  type: "bot", hp: INIT_HP, acc: 0.85, style: "anal√≠tico", alive: true, img: "../../src/img/visuales/pj_4.jpg" },
  ];

  const extraBots = [
    { id: "G", name: "Gauss",     type: "bot", hp: INIT_HP, acc: 0.65, style: "normal",    alive: true, img: "../../src/img/visuales/pj_5.jpg" },
    { id: "P", name: "Poisson",   type: "bot", hp: INIT_HP, acc: 0.60, style: "discreto",  alive: true, img: "../../src/img/visuales/pj_7.jpg" },
    { id: "C", name: "Chebyshev", type: "bot", hp: INIT_HP, acc: 0.68, style: "desigual",  alive: true, img: "../../src/img/visuales/pj_6.jpg" },
    { id: "M", name: "Markov",    type: "bot", hp: INIT_HP, acc: 0.62, style: "cadena",    alive: true, img: "../../src/img/visuales/pj_8.jpg" },
  ];

  const human = { id: "H", name: playerName, type: "human", hp: INIT_HP, acc: 0.75, alive: true, img: "../../src/img/visuales/pj_1.jpg" };

  // üîÄ Mezclamos bots aleatoriamente
  const bots = (mode === "full") 
    ? [...baseBots, ...extraBots].sort(() => Math.random() - 0.5)
    : [...baseBots].sort(() => Math.random() - 0.5);

  // üß© Orden: jugador + bots mezclados
  const players = [human, ...bots];

  return players;
}



    function togglePlayerControls(enabled) {
function togglePlayerControls(enabled) {
  const buttons = ["#btnAttack", "#btnFortify", "#btnRepair", "#btnSpy"];
  
  buttons.forEach(id => {
    const el = $(id);
    if (enabled) {
      el.classList.remove("disabled");
    } else {
      el.classList.add("disabled");
    }
  });

  // üßπ Limpiar y ocultar targetBox
  const targetBox = $("#targetBox");
  targetBox.innerHTML = "";
  targetBox.classList.remove("active", "attack-mode");

  // üß† Si est√° habilitado (es tu turno), crear botones
  if (enabled) {
    state.players.forEach((p, idx) => {
      if (idx > 0 && p.alive) {
        const btn = document.createElement("button");
        btn.className = "btn-ghost";
        btn.textContent = p.name;
        btn.onclick = () => selectTarget(idx);
        targetBox.appendChild(btn);
      }
    });
  }
}


    // Generar botones de objetivos
    const targetBox = $("#targetBox");
    targetBox.innerHTML = "";
    targetBox.classList.remove("active");

    if (enabled) {
        state.players.forEach((p, idx) => {
        if (idx > 0 && p.alive) {
            const btn = document.createElement("button");
            btn.className = "btn-ghost";
            btn.textContent = p.name;
            btn.onclick = () => selectTarget(idx);
            targetBox.appendChild(btn);
        }
        });
    }
    }

function highlightTurn() {
  const idx = state.order[state.turnIdx];
  const p = state.players[idx];
  
  $("#turnName").textContent = p ? p.name : "‚Äî";

  // Limpiar todas las celdas activas
  $$(".cell").forEach(c => c.classList.remove("active-turn"));

  // Mapeo de √≠ndices
  const idMap = { 
    0: "#player",
    1: "#p1",
    2: "#p2",
    3: "#p3",
    4: "#p4",
    5: "#p5",
    6: "#p6",
    7: "#p7",
    8: "#p8"
  };

  const sel = idMap[idx];
  if (sel) {
    const cell = $(sel);
    if (cell) {
      cell.classList.add("active-turn"); // ‚úÖ ahora aplica al .cell
    }
  }

  // Efecto de turno en el HUD inferior
const playerHUD = document.querySelector(".player-hud");
if (state.order[state.turnIdx] === 0) {
  playerHUD.classList.add("active-turn");
} else {
  playerHUD.classList.remove("active-turn");
}

}

    function current() {
    return state.players[state.order[state.turnIdx]];
    }

    // ============================================
    // TEMPORIZADOR DE TURNO
    // ============================================
function startTurnTimer() {
  clearInterval(state.interval);
  state.timer = TURN_TIME;
  state.awaitingAnswer = false; // ‚úÖ Reiniciamos flag cada nuevo turno
  updateTimerUI();

  state.interval = setInterval(() => {
    if (gameEnded || state.awaitingAnswer) return;

    state.timer -= 1;
    updateTimerUI();

    if (state.timer <= 0) {
      clearInterval(state.interval);
      onTimeOut();
    }
  }, 1000);
}

    function updateTimerUI() {
    $("#timeLeft").textContent = state.timer + "s";
    const pct = Math.max(0, (state.timer / TURN_TIME) * 100);
    const fill = $("#timerFill");
    fill.style.width = pct + "%";

    // Cambiar color seg√∫n tiempo restante
    if (state.timer > 10) {
        fill.style.background = "linear-gradient(90deg, #00d084, #9cffac)";
    } else if (state.timer > 5) {
        fill.style.background = "linear-gradient(90deg, #ffd166, #ffe29a)";
    } else {
        fill.style.background = "linear-gradient(90deg, #ff6b6b, #ffa3a3)";
    }
    }

    function onTimeOut() {
    if (gameEnded) return;
    
    const actorIdx = state.order[state.turnIdx];
    const actor = state.players[actorIdx];

    if (!actor || !actor.alive) {
        endTurn();
        return;
    }

    if (actor.type === "human") {
        actor.hp = clamp(actor.hp - 1, 0, MAX_HP);
        addLog("‚è±Ô∏è <b>Se acab√≥ tu tiempo</b>: perd√©s 1 vida.");
        checkDeath(actorIdx);
        renderAll();
    } else {
        addLog(`‚è±Ô∏è <b>${actor.name}</b> pens√≥ demasiado y perdi√≥ el turno.`);
    }

    endTurn();
    }

    // ============================================
    // ACCIONES DEL JUGADOR
    // ============================================
    function isMyTurn() {
    return state.order[state.turnIdx] === 0 && !gameEnded;
    }

  $("#btnAttack").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    state.chosenAction = "attack";
    const targetBox = $("#targetBox");
    targetBox.classList.add("active", "attack-mode"); // üî¥ activamos modo ataque visual
    addLog("‚öîÔ∏è Eleg√≠ a qui√©n atacar.");
  };


    function selectTarget(idx) {
    if (!isMyTurn() || state.awaitingAnswer) return;
    
    if (!state.players[idx] || !state.players[idx].alive) {
        addLog("‚ö†Ô∏è Ese objetivo ya no est√° disponible.");
        return;
    }
    
    state.chosenTarget = idx;
    
    if (state.chosenAction === "attack") {
        $("#targetBox").classList.remove("active");
        clearInterval(state.interval); // Pausar timer durante pregunta
        askQuestion("attack");
    }
    }

    $("#btnFortify").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    state.chosenAction = "fortify";
    clearInterval(state.interval); // Pausar timer durante pregunta
    askQuestion("fortify");
    };

    $("#btnRepair").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    const me = state.players[0];
    me.hp = clamp(me.hp + 1, 0, MAX_HP);
    addLog(`üíä <b>${me.name}</b> se cura (+1 vida).`);
    renderAll();
    endTurn();
    launchEffect("#player", "heal");
    sfx.heal.play();
    };

    $("#btnSpy").onclick = () => {
    if (!isMyTurn() || state.awaitingAnswer) return;
    state.spyBonus = true;
    const preview = rnd(QUESTIONS).topic;
    addLog(`üïµÔ∏è Espi√°s a los rivales. Tema probable: <b>${preview}</b>.`);
    $("#tip").textContent = "Espiaste: reforz√° ese tema üëâ " + preview;
    endTurn();
    };

    // ============================================
    // SISTEMA DE PREGUNTAS
    // ============================================
// ============================================
// CERRAR PREGUNTA Y REANUDAR CON TIEMPO RESTANTE
// ============================================
let savedTimer = null;

function askQuestion(kind) {
  savedTimer = state.timer; // ‚è±Ô∏è guardamos tiempo actual
  state.awaitingAnswer = true;

  $("#qModal").classList.add("active");
  const q = rnd(QUESTIONS);
  $("#qTopic").textContent = q.topic;
  $("#qTitle").textContent = q.q;
  $("#qExplain").style.display = "none";
  $("#qExplain").innerHTML = "";
  $("#chipBonus").style.display = state.spyBonus ? "inline-block" : "none";

  const optBox = $("#qOptions");
  optBox.innerHTML = "";

  const shuffled = q.options.map((text, i) => ({ text, i }))
    .sort(() => Math.random() - 0.5);

  shuffled.forEach(opt => {
    const btn = document.createElement("button");
    btn.className = "opt";
    btn.textContent = opt.text;
    btn.onclick = () => resolveQuestion(q, opt.i, kind);
    optBox.appendChild(btn);
  });
}

// ‚úÖ el correcto
$("#btnCloseQuestion").onclick = () => {
  $("#qModal").classList.remove("active");
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;
  if (savedTimer && savedTimer > 0) state.timer = savedTimer;
  if (state.order[state.turnIdx] === 0 && !gameEnded) {
    clearInterval(state.interval);
    updateTimerUI();
    state.interval = setInterval(() => {
      if (gameEnded || state.awaitingAnswer) return;
      state.timer -= 1;
      updateTimerUI();
      if (state.timer <= 0) {
        clearInterval(state.interval);
        onTimeOut();
      }
    }, 1000);
    togglePlayerControls(true);
    addLog("‚ùå Cerraste la pregunta. El turno contin√∫a.");
  }
};


function resolveQuestion(q, idx, kind) {
  if (!state.awaitingAnswer) return;
  state.awaitingAnswer = false;

  // üîí Ocultar el bot√≥n cerrar inmediatamente
  $("#btnCloseQuestion").style.display = "none";

  const correct = (idx === q.correct);
  const explainBox = $("#qExplain");
  explainBox.style.display = "block";
  
  explainBox.innerHTML = correct 
      ? "<div class='right'>‚úÖ Correcto</div>" 
      : "<div class='wrong'>‚ùå Incorrecto</div>";
  explainBox.innerHTML += "<p class='mt-1'>" + q.explain + "</p>";

  // Deshabilitar opciones
  $$(".opt").forEach(btn => btn.style.pointerEvents = "none");

  // üîÅ Esperar y cerrar
  setTimeout(() => {
    $("#qModal").classList.remove("active");
    $("#btnCloseQuestion").style.display = "inline-block"; // üîô volver a mostrar para la pr√≥xima pregunta
    applyQuestionOutcome(correct, kind);
  }, 2500);
}




function applyQuestionOutcome(correct, kind) {
  if (gameEnded) return;

  const me = state.players[0];
  if (!me || !me.alive) {
    state.awaitingAnswer = false;
    endTurn();
    return;
  }

  let success = correct;

  // Bonus de espionaje (+15% √©xito)
  if (state.spyBonus) {
    state.spyBonus = false;
    if (!success && Math.random() < 0.15) {
      success = true;
      addLog("üéØ <b>¬°Bonus de espionaje activado!</b>");
    }
  }

  // ==== ATAQUE ====
if (kind === "attack") {
  const t = state.chosenTarget;
  if (t == null || !state.players[t] || !state.players[t].alive) {
    addLog("‚ö†Ô∏è Objetivo no v√°lido.");
    state.chosenTarget = null;
    state.awaitingAnswer = false;
    endTurn();
    return;
  }

  if (success) {
    state.score += 80;
    state.players[t].hp = clamp(state.players[t].hp - 2, 0, MAX_HP);
    addLog(`‚öîÔ∏è Atac√°s a <b>${state.players[t].name}</b> con √©xito: <b>-2 vidas</b>.`);
    checkDeath(t);
    // üí• efecto visual
    flashCell("#player", "violet"); // el atacante (vos)
    flashCell(idFromIndex(t), "red"); // el objetivo
     launchProjectile("#player", idFromIndex(t));
  } else {
    me.hp = clamp(me.hp - 1, 0, MAX_HP);
    addLog(`‚öîÔ∏è Fallaste el ataque: <b>-1 vida</b> para vos.`);
    launchEffect("#player", "fail");
    checkDeath(0);
    flashCell("#player", "red");
  }
  if (success) {
  sfx.attack.play();
} else {
  sfx.fail.play();
}

}


  // ==== FORTIFICAR ====
if (kind === "fortify") {
  if (success) {
    state.score += 50;
    me.hp = clamp(me.hp + 3, 0, MAX_HP);
    addLog("üõ°Ô∏è Se cura: <b>+3 vida</b>.");
    flashCell("#player", "green");
    launchEffect("#player", "shield");
    sfx.fortify.play();
  } else {
    addLog("üõ°Ô∏è Fallaste la fortificaci√≥n (sin efecto).");
  }
  
}



  // ==== ACTUALIZAR UI ====
  $("#score").textContent = state.score;

  // ‚ö†Ô∏è CR√çTICO: limpiar flags ANTES de pasar turno
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;

  renderAll();

  // ==== PASAR TURNO ====
  if (!gameEnded) {
    endTurn();

    // üß† Si despu√©s de endTurn sigue siendo tu turno ‚Üí reanudar timer
    if (state.order[state.turnIdx] === 0 && !gameEnded) {
      startTurnTimer();
      togglePlayerControls(true);
    }
  }
}

    // ============================================
    // GESTI√ìN DE MUERTE
    // ============================================
    function checkDeath(idx) {
    if (gameEnded) return;
    
    const p = state.players[idx];
    if (!p) return;
    
    if (p.hp <= 0 && p.alive) {
        p.alive = false;
        addLog(`üí• <b>${p.name}</b> ha sido eliminado.`);

         sfx.death.play();

        // Remover del orden de turnos
        const oldOrder = [...state.order];
        state.order = state.order.filter(i => i !== idx);

        // Ajustar √≠ndice de turno si es necesario
        if (state.order.length > 0) {
        // Encontrar qui√©n sigue despu√©s del eliminado
        const wasAtIdx = oldOrder.indexOf(idx);
        if (state.turnIdx >= state.order.length) {
          state.turnIdx = 0;
        }

        // Asegurar que el √≠ndice est√© en rango
        state.turnIdx = state.turnIdx % state.order.length;
        }

        // Game over si muere el jugador
        if (idx === 0) {
        return gameOver(false);
        }

        // Bonus por eliminar bot
        const killerIsPlayer = state.order[state.turnIdx] === 0;
        if (killerIsPlayer) {
        state.score += 200;
        $("#score").textContent = state.score;
        addLog("üéâ <b>+200 puntos</b> por eliminar un rival.");
        }

        // Victoria si todos los bots murieron
        const vivosBots = state.players.slice(1).filter(x => x.alive).length;
        if (vivosBots === 0) {
        gameOver(true);
        }
    }
    }

function idFromIndex(i) {
  switch (i) {
    case 0: return "#player";
    case 1: return "#p1";
    case 2: return "#p2";
    case 3: return "#p3";
    case 4: return "#p4";
    case 5: return "#p5";
    case 6: return "#p6";
    case 7: return "#p7";
    default: return null;
  }
}


    // Hace destellar el recuadro de un jugador
function flashCell(selector, color) {
  // Buscamos directamente la celda (ya no el padre)
  const cell = $(selector);
  if (!cell) return;

  const className = `flash-${color}`;
  cell.classList.add(className);

  // Removemos despu√©s del efecto
  setTimeout(() => cell.classList.remove(className), 1200);
}



    // ============================================
    // TURNOS Y BOTS
    // ============================================
function endTurn() {
  if (gameEnded) return;

  // Reset flags
  state.awaitingAnswer = false;
  state.chosenAction = null;
  state.chosenTarget = null;

  // Avanzar al siguiente turno
  state.turnIdx = (state.turnIdx + 1) % state.order.length;

  // Si vuelve al jugador humano => nueva ronda
  if (state.turnIdx === 0) {
    state.round++;
    $("#round").textContent = state.round;
    $("#tip").textContent = rnd(baseTips);
  }

  renderAll();
  highlightTurn();
  startTurnTimer();

  // Si el turno es de un bot => ejecutar IA
  const idx = state.order[state.turnIdx];
  const player = state.players[idx];

if (player && player.type === "bot" && player.alive) {
  const turnSnapshot = state.round + "-" + state.turnIdx;
  setTimeout(() => {
    // üí° verificamos que sigue siendo su turno
    if (state.round + "-" + state.turnIdx === turnSnapshot) {
      botAct(idx);
    }
  }, 1500);
}

}

function botAct(idx) {
  if (gameEnded) return;

  // ‚ö†Ô∏è Si ya no es el turno de este bot, salir (previene bugs)
  if (state.order[state.turnIdx] !== idx) return;

  const bot = state.players[idx];
  if (!bot || !bot.alive) {
    endTurn();
    return;
  }

  let action;

  if (bot.hp <= 2) {
    action = Math.random() < 0.7 ? "fortify" : "repair";
  } else if (bot.hp >= 5) {
    action = Math.random() < 0.8 ? "attack" : "fortify";
  } else {
    const r = Math.random();
    if (r < 0.5) action = "attack";
    else if (r < 0.8) action = "fortify";
    else action = "repair";
  }

  // ==== REPARAR ====
  if (action === "repair") {
    bot.hp = clamp(bot.hp + 1, 0, MAX_HP);
    addLog(`üíä <b>${bot.name}</b> se cura (+1 vida).`);
    renderAll();
    flashCell(idFromIndex(idx), "green");
    launchEffect(idFromIndex(idx), "heal");
    sfx.heal.play();
    return endTurn();
  }

  // ==== FORTIFICAR ====
  if (action === "fortify") {
    const success = rollBot(bot, "fortify");
    if (success) {
      bot.hp = clamp(bot.hp + 1, 0, MAX_HP);
      addLog(`üõ°Ô∏è <b>${bot.name}</b> fortifica (+1 vida).`);
      launchEffect(idFromIndex(idx), "shield");
      flashCell(idFromIndex(idx), "green");
      sfx.fortify.play();
    } else {
      addLog(`üõ°Ô∏è <b>${bot.name}</b> fall√≥ la fortificaci√≥n.`);
      launchEffect(idFromIndex(idx), "fail");
    }
    renderAll();
    return endTurn();
  }

  // ==== ATAQUE ====
  if (action === "attack") {
    const targets = state.players
      .map((p, i) => ({ i, p }))
      .filter(x => x.i !== idx && x.p && x.p.alive);

    if (targets.length === 0) return endTurn();

    let target;
    const chanceAttackPlayer = 0.23;

    if (Math.random() < chanceAttackPlayer && state.players[0].alive) {
      target = { i: 0, p: state.players[0] };
    } else {
      const botsOnly = targets.filter(t => t.i !== 0);
      target = botsOnly.length > 0 ? rnd(botsOnly) : rnd(targets);
    }

    const success = rollBot(bot, "attack");

    if (success) {
      target.p.hp = clamp(target.p.hp - 2, 0, MAX_HP);
      addLog(`‚öîÔ∏è <b>${bot.name}</b> ataca a <b>${target.p.name}</b> (-2 vidas).`);
      checkDeath(target.i);
      flashCell(idFromIndex(idx), "violet");
      flashCell(idFromIndex(target.i), "red");
      sfx.attack.play();
      launchEffect(idFromIndex(target.i), "fail"); 
       launchProjectile(idFromIndex(idx), idFromIndex(target.i));
    } else {
      bot.hp = clamp(bot.hp - 1, 0, MAX_HP);
      addLog(`‚öîÔ∏è <b>${bot.name}</b> fall√≥ y se da√±√≥ (-1 vida).`);
      checkDeath(idx);
      flashCell(idFromIndex(idx), "red");
      launchEffect(idFromIndex(target.i), "fail"); 
      sfx.fail.play();
    }

    renderAll();
    return endTurn();
  }
}

    function rollBot(bot, kind) {
    let acc = bot.acc;

    // Ajustes por personalidad
    const topic = rnd(["Independencia", "Uni√≥n", "Complemento", "Condicional", "Bayes", "Prob. total"]);
    
    if (bot.name === "Frecuent√≠n" && topic === "Independencia") {
        acc -= 0.1;
    }
    if (bot.name === "Bayesito" && (topic === "Bayes" || topic === "Condicional")) {
        acc += 0.08;
    }

    acc = clamp(acc, 0.1, 0.95);
    return Math.random() < acc;
    }

// =====================================================
// ANIMACI√ìN DE PROYECTIL R√ÅPIDO (VIOLETA)
// =====================================================
function launchProjectile(fromSelector, toSelector) {
  const fromEl = document.querySelector(fromSelector);
  const toEl = document.querySelector(toSelector);
  if (!fromEl || !toEl) return;

  const fromRect = fromEl.getBoundingClientRect();
  const toRect = toEl.getBoundingClientRect();

  // Crear proyectil
  const projectile = document.createElement("div");
  projectile.className = "projectile";
  document.body.appendChild(projectile);

  // Posici√≥n inicial
  const startX = fromRect.left + fromRect.width / 2;
  const startY = fromRect.top + fromRect.height / 2;
  const endX = toRect.left + toRect.width / 2;
  const endY = toRect.top + toRect.height / 2;

  projectile.style.left = `${startX}px`;
  projectile.style.top = `${startY}px`;

  // Forzar reflow para que la transici√≥n se aplique
  void projectile.offsetWidth;

  const dx = endX - startX;
  const dy = endY - startY;

  // Movimiento r√°pido (m√°s corto)
  projectile.style.transitionDuration = "0.35s";
  projectile.style.transform = `translate(${dx}px, ${dy}px) scale(1.3)`;

  // Desvanecer y eliminar despu√©s del impacto
  setTimeout(() => {
    projectile.style.opacity = "0";
    setTimeout(() => projectile.remove(), 200);
  }, 350);
}

// =====================================================
// EFECTOS DE CURACI√ìN / FORTIFICACI√ìN / FALLO
// =====================================================
function launchEffect(selector, type) {
  const targetEl = document.querySelector(selector);
  if (!targetEl) return;

  const rect = targetEl.getBoundingClientRect();
  const effect = document.createElement("div");
  effect.className = `effect-${type}`;

  document.body.appendChild(effect);
  effect.style.left = `${rect.left + rect.width / 2}px`;
  effect.style.top = `${rect.top + rect.height / 2}px`;

  setTimeout(() => effect.remove(), 1000);
}

    // ============================================
    // FIN DE JUEGO
    // ============================================
    function gameOver(win) {
    if (gameEnded) return;
    
    gameEnded = true;
    clearInterval(state.interval);

    const vivos = state.players.filter(p => p && p.alive);
    $("#endTitle").textContent = win ? "üèÜ ¬°Ganaste!" : "üíÄ Game Over";
    $("#endStats").innerHTML = `
        Rondas: <b>${state.round}</b> ¬∑ 
        Puntaje: <b>${state.score}</b> ¬∑ 
        Vivos: ${vivos.map(v => v.name).join(", ") || "Ninguno"}
    `;

    // Actualizar mejor puntaje
    const best = Number(localStorage.getItem("bp_best") || 0);
    if (state.score > best) {
        localStorage.setItem("bp_best", String(state.score));
        addLog(`üéä <b>¬°Nuevo r√©cord: ${state.score} puntos!</b>`);
    }
    $("#best").textContent = Math.max(best, state.score);

// üéµ Detener m√∫sica y reproducir sonido final
music.pause();
music.currentTime = 0; // reinicia la canci√≥n para la pr√≥xima

if (win) {
  sfx.victory.play();
} else {
  sfx.gameover.play();
}

// Mostrar overlay despu√©s de un breve retardo
setTimeout(() => {
  $("#endOverlay").classList.add("active");
}, 500);

    }

    // ============================================
    // UI: INICIO Y REINICIO
    // ============================================
// ============================================
// UI: INICIO Y REINICIO
// ============================================

// ‚úÖ versi√≥n corregida con carga de preguntas antes de iniciar
$("#btnStart").onclick = async () => {
  const name = ($("#playerNameInput").value || "Jugador").trim().slice(0, 20);
  await loadQuestions();
  const mode = $("#modeFull").checked ? "full" : "normal";
  $("#startOverlay").classList.remove("active");
  newGame(name, mode);
  const grid = document.getElementById("grid");
grid.classList.remove("normal", "full");
grid.classList.add(mode === "full" ? "full" : "normal");

};

$("#btnRestart").onclick = () => {
  location.reload();
};

$("#btnPlayAgain").onclick = () => {
  $("#endOverlay").classList.remove("active");
  const name = state.players[0].name;
  const mode = (state.players.length >= 8) ? "full" : "normal";

  // üéµ Reiniciar y reproducir m√∫sica desde el inicio
  music.currentTime = 0;
  music.play();
  $("#btnPlayMusic").textContent = "‚è∏Ô∏è";

  newGame(name, mode);
  const grid = document.getElementById("grid");
  grid.classList.remove("normal", "full");
  grid.classList.add(mode === "full" ? "full" : "normal");
};



$("#btnHelp").onclick = () => {
  alert(
    "üìñ BATALLA DE PROBABILIDAD\n\n" +
    "OBJETIVO: Sobrevivir eliminando los rivales.\n\n" +
    "ACCIONES:\n" +
    "‚öîÔ∏è Atacar: Resuelve pregunta. √âxito = -2 HP al rival. Fallo = -1 HP tuyo.\n" +
    "üõ°Ô∏è Fortificar: Resuelve pregunta. √âxito = +3 HP tuyo.\n" +
    "üíä Curarse: +1 HP instant√°neo (sin pregunta).\n" +
    "üïµÔ∏è Espiar: Ver tema pr√≥ximo + 15% bonus en siguiente pregunta.\n\n" +
    "‚è±Ô∏è Ten√©s 20 segundos por turno. Si no actu√°s, perd√©s 1 vida.\n\n" +
    "¬°Buena suerte!"
  );
};

// ===========================
// AUDIO SYSTEM
// ===========================
const music = new Audio("../../src/audio/gameBattle/song.mp3");
music.loop = true;
music.volume = 0.15;

const sfx = {
  heal: new Audio("../../src/audio/gameBattle/heal.mp3"),
  fortify: new Audio("../../src/audio/gameBattle//heal.mp3"),
  attack: new Audio("../../src/audio/gameBattle/attack.mp3"),
  fail: new Audio("../../src/audio/gameBattle/miss.mp3"),
  victory: new Audio("../../src/audio/gameBattle/victory.mp3"),
  gameover: new Audio("../../src/audio/gameBattle/gameover.mp3"),
  death: new Audio("../../src/audio/gameBattle/npcdeath.mp3") 
};

// üîä Aplicar volumen inicial del slider a todos los sonidos
const initialVol = parseFloat($("#volumeControl").value);
music.volume = initialVol;
Object.values(sfx).forEach(a => (a.volume = initialVol));


$("#btnPlayMusic").onclick = () => {
  if (music.paused) {
    music.play();
    $("#btnPlayMusic").textContent = "‚è∏Ô∏è";
  } else {
    music.pause();
    $("#btnPlayMusic").textContent = "‚ñ∂Ô∏è";
  }
};

$("#volumeControl").oninput = e => {
  const v = parseFloat(e.target.value);
  music.volume = v;
  Object.values(sfx).forEach(a => (a.volume = v));
};


    // ============================================
    // INICIALIZACI√ìN
    // ============================================
    // Render inicial vac√≠o al cargar la p√°gina
    if ($("#player")) {
["#player", "#p1", "#p2", "#p3"].forEach(sel => {
  const box = $(sel);
  if (box) {
    box.innerHTML = `
      <div class="name muted">‚Äî</div>
      <div class="lifes">ü§çü§çü§çü§çü§ç</div>
    `;
  }
});

    }
    </script>

</body> 

</html>